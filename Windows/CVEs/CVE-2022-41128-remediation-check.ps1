[CmdletBinding()]
param (
    [Parameter(Mandatory=$true)]
    [string]
    $Path
)

# Ensure path to CSV is valid
$pathTest = Test-Path -Path $Path

# If path is not valid
if (!$pathTest) {
    do {
        # Prompt for new path and retest
        Write-Host -ForegroundColor Red "`nPath does not exist`n"
        $Path = Read-Host -Prompt "Please enter a valid path to CSV file"
        $pathTest = Test-Path -Path $Path
    } until (
        # Check if path is now valid
        $pathTest -eq $true
    )
}

# Import CSV
$list = Import-Csv -Path $Path
Write-Host "List imported"

# Get admin credentials
$creds = Get-Credential

# Create blank object for query results
$results = @()

# Query each server in list for specified KB
foreach ($server in $list) {
    Write-Host "Starting query for " -NoNewline
    Write-Host $server.Name -ForegroundColor Cyan
    
    # Reset variables
    $queryError = $null
    $systemInfo = $null
    $installedUpdates = $null

    # Gather installed updates
    $scriptBlock = {
        # Get a WUA Session
        $session = (New-Object -ComObject 'Microsoft.Update.Session')

        # Query the latest 1000 History starting with the first record
        $history = $session.QueryHistory("",0,50) | ForEach-Object {
            # Make the properties hidden in com properties visible.
            $Product = $_.Categories | Where-Object {$_.Type -eq 'Product'} | Select-Object -First 1 -ExpandProperty Name
            $_ | Add-Member -MemberType NoteProperty -Value $_.UpdateIdentity.UpdateId -Name UpdateId
            $_ | Add-Member -MemberType NoteProperty -Value $_.UpdateIdentity.RevisionNumber -Name RevisionNumber
            $_ | Add-Member -MemberType NoteProperty -Value $Product -Name Product -PassThru
            Write-Output $_
        }

        #Remove null records and only return the fields we want
        $history | Where-Object {![String]::IsNullOrWhiteSpace($_.title)} |
        Select-Object Date, Title, SupportUrl, Product, UpdateId, RevisionNumber
    }

    $installedUpdates = Invoke-Command -ComputerName $server.Name -ScriptBlock $scriptBlock `
            -Credential $creds -ErrorAction SilentlyContinue -ErrorVariable queryError
            
    # If there is no error
    if (!$queryError) {
        # Gather OS Build
        $scriptBlock = {[System.Environment]::OSVersion.Version}
        $systemInfo = Invoke-Command -ComputerName $server.Name -ScriptBlock $scriptBlock `
                -Credential $creds
        Write-Host "OS Version: $systemInfo"

        # Get KB(s) to check against
        $kbs = switch ($systemInfo.Build) {
            9200 {5019958}
            9200 {5020003}
            9200 {5020009}
            9600 {5020023}
            10240 {5019970}
            14393 {5019964}
            17763 {5019966}
            19042 {5019959}
            19043 {5019959}
            19044 {5019959}
            19045 {5019959}
            20348 {5019081}
            22000 {5019961}
            22621 {5019980}
        }

        # For each applicable KB
        foreach ($kb in $kbs) {
            Write-Host "Checking KB$($kb)"

            # Create flag
            $installed = $false

            # Check if the KB is installed
            foreach ($update in $installedUpdates) {
                if ($update.Title -match $kb) {
                    Write-Host "Found: $($update.Title)"
                    $installed = $true
                    break
                }
            }

            # Query results
            $queryResults = [ordered]@{
                Name = $server.Name
                OSVersion = $systemInfo
                KB = $kb
                Installed = $installed
                Error = $null
            }

            # Add query results to global results object
            $results += New-Object -TypeName PSObject -Property $queryResults

            Write-Host "Query complete`n"
        }
    }
    # Otherwise the status is unknown
    else {
        # Query results
        $queryResults = [ordered]@{
            Name = $server.Name
            OSVersion = $null
            KB = $null
            Installed = $null
            Error = $queryError[0]
        }

        # Add query results to global results object
        $results += New-Object -TypeName PSObject -Property $queryResults

        Write-Host "Query complete`n"
    }
}

# Define query results export path
$exportPath = "C:\temp\CVE-2022-41128-remediation-check-results.csv"

# Remove previous query results export, if it exists
if (Test-Path -Path $exportPath) {
    Remove-Item -Path $exportPath
}

# Export query results to CSV
$results | Export-Csv -Path $exportPath
